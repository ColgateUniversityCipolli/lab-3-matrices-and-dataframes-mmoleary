---
title: Lab Three -- Matrices and Data Frames in R # Title of the document

# Bibliography Details
bibliography: Lab3References.bib  # Name of bib file in the same folder 
bibliographystyle: apa                   # Bibliography style

execute:
  warning: false
  message: false

# Below will do html by default. To render the entire project
# Use the following code:
# quarto::quarto_render("Lab3WriteUp.qmd")

format:
  html: 
    number-sections: TRUE
    code-fold: TRUE
    code-line-numbers: TRUE
    cap-location: top 
  pdf:
    documentclass: article
    number-sections: TRUE
    reference-section-title: "References" 
    code-line-numbers: TRUE
    cap-location: top 
    include-in-header:
      - text: |
          \usepackage{amsmath}
          \usepackage[dvipsnames]{xcolor}
          \usepackage[shortlabels]{enumitem}
          \usepackage{parskip}
          \usepackage{hyperref}
          \usepackage{geometry}
          \usepackage{float}
    geometry:
      - top=0.75in
      - left=0.75in
      - bottom=0.75in
      - right=0.75in
format-links: [pdf]
---
```{r}
#| echo: false

default_chunk_hook  <- knitr::knit_hooks$get("chunk")

latex_font_size <- c("Huge", "huge", "LARGE", "Large", 
                     "large", "normalsize", "small", 
                     "footnotesize", "scriptsize", "tiny")

knitr::knit_hooks$set(chunk = function(x, options) {
  x <- default_chunk_hook(x, options)
  if(options$size %in% latex_font_size) {
    paste0("\n \\", options$size, "\n\n", 
      x, 
      "\n\n \\normalsize"
    )
  } else {
    x
  }
})

```

```{r}
#| label: load-packages
#| include: false
library(tidyverse)
```

* Complete the tasks below. Make sure to start your solutions in on a new line that starts with "**Solution**:".
* Make sure to use the Quarto Cheatsheet. This will make completing and writing up the lab *much* easier.

Consider the unit square depicted in @fig-unitsquare. 

```{r}
#| label: fig-unitsquare
#| fig-cap: "The unit square."
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"
p0 <- c(0, 0)
p1 <- c(1, 0)
p2 <- c(1, 1)
p3 <- c(0, 1)
ggplot() +
  geom_segment(aes(x = p0[1], y = p0[2], xend = p1[1], yend = p1[2])) +
  geom_segment(aes(x = p1[1], y = p1[2], xend = p2[1], yend = p2[2])) +
  geom_segment(aes(x = p2[1], y = p2[2], xend = p3[1], yend = p3[2])) +
  geom_segment(aes(x = p3[1], y = p3[2], xend = p0[1], yend = p0[2])) +
  theme_bw() +
  xlim(-0.5, 1.5) +
  ylim(-0.5, 1.5) +
  labs(x = "x", y = "y")
```

The unit square can be defined by two basis vectors
$$\mathbf{v}_1=\begin{bmatrix} 1 \\ 0 \end{bmatrix} ~~~ \textrm{and} ~~~ \mathbf{v}_2=\begin{bmatrix} 0 \\ 1 \end{bmatrix}.$$
From these vectors, we can compute the corner vertices.
\begin{align*}
  p_0 & = (0,0) = (x_0, y_0) \tag{The origin}\\
  p_1 & = v_1 = (x_1, y_1) = (1,0)  \tag{The first basis vector}\\
  p_2 & = v_1 + v_2 = (x_2, y_2)= (1,1) \tag{The sum of basis vectors}\\
  p_3 & = v_2 = (x_3, y_3) =(0,1) \tag{The second basis vector}\\
\end{align*}
Note that the segments that form the boundary go from $p_0$ to $p_1$ to $p_2$ to $p_3$ and back to $p_0$.

Consider the matrix $M$ to be the matrix we get from binding the two basis vectors at the column,
$$\mathbf{M} = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}.$$

# Question 1
Let's transform $\mathbf{M}$ to demonstrate an interesting linear algebra property.

## Part a
Create the matrix `A` in `R`.
$$\mathbf{A} = \begin{bmatrix} 1 & -7 \\ 5 & 9 \end{bmatrix}$$

**Solution** 

```{r}
#| size: scriptsize
A = matrix(data = c(1, -7, 5, 9), nrow = 2, ncol = 2, byrow = TRUE) 
A
#I made a matrix that went by row instead of by column.
```

## Part b
Compute the product below in `R` and store it in an object `T`.
$$\mathbf{T} = \mathbf{A}\mathbf{M}.$$

**Solution**

```{r}
#| size: scriptsize
M = matrix(data = c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE) # Making the matrix, M
T = A%*%M #Multiplying the matrices and naming them T
T
```

## Part c
Create `basis.vector.1` (first column of `T`) and `basis.vector.2` (second column of `T`) in `R`.

**Solution**

```{r}
#| size: "scriptsize"
basis.vector.1 = c(1,5) 
basis.vector.2 = c(-7,9) #I used a manual vector because there were only two data points.
basis.vector.1
basis.vector.2
```

## Part d
Compute the points $p_0$, $p_1$, $p_2$, and $p_3$.

**Solution**

```{r}
#| size: scriptsize
p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2 #I used the formulas from the unit square example for the corner vertices.
p0
p1
p2
p3
```

## Part e
Copy and paste the code for the unit square. Edit the code to draw the segments that form the boundary based on the points in Part d.

**Solution**

```{r}
#| label: fig-1.5e
#| fig-cap: "Parallelogram 1."
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"
p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2 # I made sure to use the same points as found in part d.
ggplot() +
  geom_segment(aes(x = p0[1], y = p0[2], xend = p1[1], yend = p1[2])) +
  geom_segment(aes(x = p1[1], y = p1[2], xend = p2[1], yend = p2[2])) +
  geom_segment(aes(x = p2[1], y = p2[2], xend = p3[1], yend = p3[2])) +
  geom_segment(aes(x = p3[1], y = p3[2], xend = p0[1], yend = p0[2])) +
  theme_bw() +
  xlim(-15, 15) +
  ylim(-5, 25) +
  labs(x = "x", y = "y")
```

## Part f
Interestingly, the determinant of $\mathbf{A}$ gives us the area of the shape plotted in Part e. Find the determinant of $\mathbf{A}$.

**Solution**

```{r}
#| size: scriptsize
det(A) #returns the determinant of A
```

# Question 2
Recomplete Question 1 using a new matrix for $\mathbf{A}$. This matrix is not as well behaved.

## Part a
Create the matrix `A` in `R`.
$$\mathbf{A} = \begin{bmatrix} 1 & 2 \\ 2 & 4 \end{bmatrix}$$

**Solution**

```{r}
#| size: scriptsize
A = matrix(data = c(1, 2, 2, 4), nrow = 2, ncol = 2, byrow = TRUE) 
#I made a matrix that went by row instead of by column with new data.
A
```

## Part b
Compute the product below in `R` and store it in an object `T`.
$$\mathbf{T} = \mathbf{A}\mathbf{M}.$$

```{r}
T = A %*% M # I made sure to multiply the matrices rather than their components.
T
```

## Part c
Create `basis.vector.1` (first column of `T`) and `basis.vector.2` (second column of `T`) in `R`.

```{r}
#| size: scriptsize
basis.vector.1 = c(1,2)
basis.vector.2 = c(2,4)
basis.vector.1 
basis.vector.2
```

## Part d
Compute the points $p_0$, $p_1$, $p_2$, and $p_3$.

**Solution**

```{r}
#| size: scriptsize
p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2 #same work as 1.4
p0
p1
p2
p3
```

## Part e
Copy and paste the code for plotting the unit square. Edit the code to draw the segments that form the boundary based on the points in Part d.

**Solution**

```{r}
#| label: fig-2.5e
#| fig-cap: "Line 1."
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"
p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2
ggplot() +
  geom_segment(aes(x = p0[1], y = p0[2], xend = p1[1], yend = p1[2])) +
  geom_segment(aes(x = p1[1], y = p1[2], xend = p2[1], yend = p2[2])) +
  geom_segment(aes(x = p2[1], y = p2[2], xend = p3[1], yend = p3[2])) +
  geom_segment(aes(x = p3[1], y = p3[2], xend = p0[1], yend = p0[2])) +
  theme_bw() +
  xlim(-15, 15) +
  ylim(-5, 25) +
  labs(x = "x", y = "y")
```

**Note**: As you continue to plot this here and through question 2, you will find that the $x$ and $y$ limits need to change. Try `xlim(-15,15)` and `ylim(-5, 25)`.

## Part f
Interestingly, the determinant of $\mathbf{A}$ gives us the area of the shape plotted in Part e. Find the determinant of $\mathbf{A}$.

**Solution**

```{r}
#| size: "scriptsize"
det(A) #it is a line so this should return 0.
```

# Question 3
We can conduct a shear transformation that keeps the area of the shape the same but horizontally or vertically slants the object. 

In fact, this is one of the ways artists can make something look like it's leaning or being pushed. Other applications where this is useful include fluid dynamics and crystallography, where the area of a deformed object must remain constant, or in photography where perspective in photos can be adjusted.

A shear transformation is implemented by altering the basis vectors we start with. For vertical slanting,
$$\mathbf{M}_v = \begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix}$$
and for horizontal slanting
$$\mathbf{M}_h = \begin{bmatrix} 1 & 0 \\ k & 1 \end{bmatrix}.$$
In both cases, $k \in \mathbb{R}$ is called a shear factor and its sign determines the direction of the slant and its magnitude determines the severity of the slant.

## Part a
Use the following to generate a new shape. Compare the shape and its area to your answer in Question 1.
$$\mathbf{M}_v = \begin{bmatrix} 1 & k=0.5 \\ 0 & 1 \end{bmatrix} ~~~~~ \textrm{and} ~~~~~
  \mathbf{A}   = \begin{bmatrix} 1 & -7 \\ 5 & 9 \end{bmatrix}$$

**Solution**

```{r}
#| label: fig-4
#| fig-cap: "Parallelogram 2."
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"
Mv = matrix(data= c(1, k=0.5, 0, 1), nrow=2, ncol = 2, byrow = TRUE)
A = matrix(data = c(1, -7, 5, 9), nrow = 2, ncol = 2, byrow = TRUE) 
T = A%*%Mv
T
det(A) #For area of the parallelogram
basis.vector.1 = c(1,5) 
basis.vector.2 = c(-6.5,11.5) 

p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2
ggplot() +
  geom_segment(aes(x = p0[1], y = p0[2], xend = p1[1], yend = p1[2])) +
  geom_segment(aes(x = p1[1], y = p1[2], xend = p2[1], yend = p2[2])) +
  geom_segment(aes(x = p2[1], y = p2[2], xend = p3[1], yend = p3[2])) +
  geom_segment(aes(x = p3[1], y = p3[2], xend = p0[1], yend = p0[2])) +
  theme_bw() +
  xlim(-15, 15) +
  ylim(-5, 25) +
  labs(x = "x", y = "y")
```
 @fig-4 has different side lengths and angles than @fig-1.5e (giving it a stretched appearance), however their areas are the same, as shown by them having the same determinants of their respective matrix A.

## Part b
Use the following to generate a new shape. Compare the shape and its area to your answer in Questions 1 and the vertical shear transform in part (a).
$$ \mathbf{M}_h = \begin{bmatrix} 1 & 0 \\ k=0.5 & 1 \end{bmatrix}~~~~~ \textrm{and} ~~~~~
  \mathbf{A}   = \begin{bmatrix} 1 & -7 \\ 5 & 9 \end{bmatrix}$$

**Solution**

```{r}
#| label: fig-5
#| fig-cap: "Parallelogram 3"
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"

Mh = matrix(data= c(1, 0, k=0.5, 1), nrow=2, ncol = 2, byrow = TRUE)
A = matrix(data = c(1, -7, 5, 9), nrow = 2, ncol = 2, byrow = TRUE) 
T = A%*%Mh
T
det(A) #For area of the parallelogram

basis.vector.1 = c(-2.5,9.5) 
basis.vector.2 = c(-7,9) 
p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2

ggplot() +
  geom_segment(aes(x = p0[1], y = p0[2], xend = p1[1], yend = p1[2])) +
  geom_segment(aes(x = p1[1], y = p1[2], xend = p2[1], yend = p2[2])) +
  geom_segment(aes(x = p2[1], y = p2[2], xend = p3[1], yend = p3[2])) +
  geom_segment(aes(x = p3[1], y = p3[2], xend = p0[1], yend = p0[2])) +
  theme_bw() +
  xlim(-15, 15) +
  ylim(-5, 25) +
  labs(x = "x", y = "y")
```

Compared to @fig-4, @fig-5 is significantly stretched and both its acute and obtuse angles are more extreme. But because it has the same matrix A, it has the same area as the past parallelograms.

## Part c
Can we shear vertically and horizontally at the same time? Use the following to generate a new shape. Compare the shape and its area to your answers in parts (a) and (b).
$$\mathbf{M}_{vh} = \begin{bmatrix} 1 & k=0.5 \\ k=0.5 & 1 \end{bmatrix} ~~~~~ \textrm{and} ~~~~~
  \mathbf{A}   = \begin{bmatrix} 1 & -7 \\ 5 & 9 \end{bmatrix}$$

**Solution**

```{r}
#| label: fig-6
#| fig-cap: "Parallelogram 4"
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"#| size: "scriptsize"

Mvh = matrix(data= c(1, k=0.5, k=0.5, 1), nrow=2, ncol = 2, byrow = TRUE)
A = matrix(data = c(1, -7, 5, 9), nrow = 2, ncol = 2, byrow = TRUE) 
T = A%*%Mvh
T
det(A) #For area of the parallelogram

basis.vector.1 = c(-2.5,9.5) 
basis.vector.2 = c(-6.5,11.5) 
p0 = c(0,0)
p1 = basis.vector.1
p2 = basis.vector.1+basis.vector.2
p3 = basis.vector.2
ggplot() +
  geom_segment(aes(x = p0[1], y = p0[2], xend = p1[1], yend = p1[2])) +
  geom_segment(aes(x = p1[1], y = p1[2], xend = p2[1], yend = p2[2])) +
  geom_segment(aes(x = p2[1], y = p2[2], xend = p3[1], yend = p3[2])) +
  geom_segment(aes(x = p3[1], y = p3[2], xend = p0[1], yend = p0[2])) +
  theme_bw() +
  xlim(-15, 15) +
  ylim(-5, 25) +
  labs(x = "x", y = "y")
```

Similar to the differnce between @fig-4 and @fig-5, @fig-6 is even further stretched compared to the shapes in part a and b. But because it has the same matrix A, it has the same area as the past parallelograms.

# Question 4

## Part a
Create a data frame `ladder` with the following data. Note your data frame should have three columns; I split it to save vertical space here.

| x    | y    | group| x    | y    | group|
|:-----|:-----|:-----|:-----|:-----|:-----|
| 0    | 0    |    1 | 1    | 8    |    6 |
| 0    | 20   |    1 | 0    | 10   |    7 |
| 1    | 0    |    2 | 1    | 10   |    7 |
| 1    | 20   |    2 | 0    | 12   |    8 |
| 0    | 2    |    3 | 1    | 12   |    8 |
| 1    | 2    |    3 | 0    | 14   |    9 |
| 0    | 4    |    4 | 1    | 14   |    9 |
| 1    | 4    |    4 | 0    | 16   |   10 |
| 0    | 6    |    5 | 1    | 16   |   10 |
| 1    | 6    |    5 | 0    | 18   |   11 |
| 0    | 8    |    6 | 1    | 18   |   11 |

**Solution**

```{r}
x = c(0,0,1,1, rep(c(0,1), times=9)) 
y = c(0,20,0,20, rep(seq(from = 2, to= 18, by=2), each= 2))
group = rep(seq(from=1, to= 11, by=1), each=2)
ladder = data.frame(x, y, group)
ladder
```

## Part b
Remove `#|eval: false` in the code below. The result should look like a ladder and a very rectangular house if part a is correct.

```{r}
#| label: fig-ladder
#| fig-cap: "A ladder."
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"
ggplot() +
  geom_path(data = ladder, 
              aes(x = x, y = y, group = group)) +
                  geom_segment(aes(x = 10, xend = 10,
                   y=0, yend = 20))+
  geom_segment(aes(x = 10, xend = 20,
                   y=20, yend = 20))+
  geom_segment(aes(x = 20, xend = 20,
                   y=0, yend = 20))+
  geom_segment(aes(x = 10, xend = 20,
                   y=0, yend = 0)) +
  theme_bw() +
  xlim(-2,22) +
  ylim(-2,22)
```

## Part c
Use `as.matrix()` to create a $22 \times 2$ matrix $\mathbf{A}$ containing the `x` and `y` observations from the `ladder` data frame. Use matrix multiplication to compute
$$\mathbf{T} = \mathbf{A} \mathbf{M}_h.$$
Recall, 
$$\mathbf{M}_h = \begin{bmatrix} 1 & 0 \\ k & 1 \end{bmatrix}$$
and use $k=0.5.$

**Solution**

```{r}
A = as.matrix(ladder[ ,-3]) # a matrix with "ladder" data without the group index.
k=0.5
Mh= matrix(data= c(1, 0, k, 1), nrow=2, ncol = 2, byrow = TRUE) 
T= A %*% Mh
T
```

## Part d
Create a data frame `leaning.ladder` with the `x` and `y` equal to the first and second column of $\mathbf{T}$, respectively, and the same values of `group` from `ladder`. 

**Solution**

```{r}
leaning.ladder = data.frame(x=T[, 1], #this uses exclusively the first index from T
                            y=T[, 2], #this uses exclusively the second index from T
                            group = group)
leaning.ladder
```

## Part e
Remove `eval: false` in the code below. The result should look like a ladder and a very rectangular house if part a is correct. The new leaning ladder should look like it is leaning on the house.

**Solution**

```{r}
#| label: fig-ladder2
#| fig-cap: "A ladder and a leaning ladder."
#| fig-width: 3
#| fig-height: 3
#| scale: "80%"
#| fig-align: "center"
#| size: "scriptsize"
ggplot() +
  geom_path(data = ladder, 
              aes(x = x, y = y, group = group, color = "Starting Ladder")) +
  geom_path(data = leaning.ladder, 
              aes(x = x, y = y, group = group, color = "Leaning Ladder")) +
  geom_segment(aes(x = 10, xend = 10,
                   y=0, yend = 20))+
  geom_segment(aes(x = 10, xend = 20,
                   y=20, yend = 20))+
  geom_segment(aes(x = 20, xend = 20,
                   y=0, yend = 20))+
  geom_segment(aes(x = 10, xend = 20,
                   y=0, yend = 0)) +
  theme_bw() +
  xlim(-2,22) +
  ylim(-2,22) +
  scale_color_manual("", values=c("darkred", "grey"))
```

# Citations

I used the tidyverse package [@tidyverse] for developing figures and R [@R] as my coding program.